name: Version Bump

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "docs/**"
      - ".github/workflows/ci.yml"

permissions:
  contents: write

jobs:
  bump:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip-version]')"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check if current commit is already tagged
        id: check
        run: |
          if git tag --points-at HEAD | grep -qE '^v[0-9]'; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "Current commit already has a version tag, skipping."
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Get latest tag
        id: latest
        if: steps.check.outputs.skip != 'true'
        run: |
          TAG=$(git tag -l 'v*' --sort=-v:refname | head -n1)
          if [ -z "$TAG" ]; then
            TAG="v0.0.0"
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Latest tag: $TAG"

      - name: Determine bump type from commits
        id: bump
        if: steps.check.outputs.skip != 'true'
        run: |
          LATEST="${{ steps.latest.outputs.tag }}"

          # Get commit messages since last tag
          if [ "$LATEST" = "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%s" HEAD)
          else
            COMMITS=$(git log --pretty=format:"%s" "${LATEST}..HEAD")
          fi

          if [ -z "$COMMITS" ]; then
            echo "type=none" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Commits since $LATEST:"
          echo "$COMMITS"

          # Check for breaking changes -> major
          if echo "$COMMITS" | grep -qiE '^(feat|fix|refactor).*!:|BREAKING CHANGE'; then
            echo "type=major" >> "$GITHUB_OUTPUT"
          # Check for features -> minor
          elif echo "$COMMITS" | grep -qiE '^feat'; then
            echo "type=minor" >> "$GITHUB_OUTPUT"
          # Everything else (fix, chore, docs, etc.) -> patch
          else
            echo "type=patch" >> "$GITHUB_OUTPUT"
          fi

      - name: Compute next version
        id: next
        if: steps.check.outputs.skip != 'true' && steps.bump.outputs.type != 'none'
        run: |
          CURRENT="${{ steps.latest.outputs.tag }}"
          CURRENT="${CURRENT#v}"

          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          case "${{ steps.bump.outputs.type }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac

          NEXT="v${MAJOR}.${MINOR}.${PATCH}"
          echo "version=$NEXT" >> "$GITHUB_OUTPUT"
          echo "Next version: $NEXT (${{ steps.bump.outputs.type }} bump)"

      - name: Create and push tag
        if: steps.check.outputs.skip != 'true' && steps.bump.outputs.type != 'none'
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          git tag -a "${{ steps.next.outputs.version }}" -m "Release ${{ steps.next.outputs.version }}"
          git push origin "${{ steps.next.outputs.version }}"
          echo "Tagged and pushed ${{ steps.next.outputs.version }}"
